%% ------------------------------------------------------- %%
%% SMT-LIB 1.2
%% ------------------------------------------------------- %%
\section{From Event-B to SMT-LIB 1.2}
\subsection{From Event-B AST to SMT-LIB v1.2 AST}
The purpose of this section is to give the translation from the Event-B Abstract Syntax Tree (AST) to an SMT-LIB AST.
The \texttt{org.eventb.core.ast} plug-in for the Rodin platform allows to manipulate Event-B mathematical formulas as trees of nodes. 

The translation is expressed in a left-to-right direction, with the $\rightsquigarrow$ symbol. For example, the following conversion indicates that the
SMT-LIB syntax for the $(x < y)$ Event-B formula is $(< x~y)$:\[ (x < y) \rightsquigarrow (< x~y) \]

\paragraph{From SET to FOL}
A many-sorted formula, i.e.\ a formula containing set symbols (let's call it a SET formula), can be translated into an equivalent one belonging to first-order logic (FOL). It is enough to be convinced of such a transformation to think to the characteristic function, which takes the value 1 for elements in the set X and the value 0 for other elements. 
Note that this translation only applies to formulas based on basic sets (i.e sets that are not sets of sets), and we only refer to basic sets in the following sections. For any basic set $E$, let's introduce the unary predicate $E_x$ such that $E_x$ is true if and only if $x$ belongs to $E$.

The translation from a SET formula to a FOL formula is defined in Table \ref{SET2FOL}, where $E$ and $F$ are sets. Both formulas are expressed in Event-B language syntax. 
\begin{table}[htbp]
\begin{center}
\begin{tabular}{|c|c|}
 \hline
 \textbf{SET formula} & \textbf{FOL formula} \\ 
 \hline
 $x \in E$ & $E_x$ \\ 
 $x \notin E$ & $\neg E_x$ \\
 $E \subseteq F$ & $\forall{x}.(E_x \Rightarrow F_x)$ \\ 
 $E \nsubseteq F$ & $\exists{x}.(E_x \wedge \neg F_x)$ \\ 
 $E \subset F$ & $\forall{x}.(E_x \Rightarrow F_x) \wedge \exists{x}.(\neg E_x \wedge F_x)$ \\ 
 $E \not\subset F$ & $\forall{x}.(F_x \Rightarrow E_x) \wedge \exists{x}.(\neg F_x \wedge E_x)$ \\ 
 $E = F$ & $\forall{x}.(E_x \Longleftrightarrow F_x)$ \\ 
 $E \neq F$ & $\exists{x}.(E_x \wedge \neg F_x) \vee \exists{x}.(F_x \wedge \neg E_x)$ \\ 
 $x \in E \cap F$ & $E_x \wedge F_x$ \\ 
 $x \in E \cup F$ & $E_x \vee F_x$ \\ 
 $x \in E \setminus F$ & $E_x \wedge \neg F_x$ \\
 $x \in \{x_1, ..., x_n\}$ & $x = x_1 \vee ... \vee x = x_n$ \\
 $x \in \varnothing$ & $\perp$ \\
 $x \in x_1 .. x_n$ & $(x \geqslant x_1) \wedge (x \leqslant x_n)$ \\
 $x \in \nat$ & $x \geqslant 0$ \\
 $x \in \natn$ & $x > 0$ \\
 $x = \min(E)$ & $ E_x \wedge \forall{y}.(E_y \Rightarrow (y \geqslant x))$ \\
 $x = \max(E)$ & $ E_x \wedge \forall{y}.(E_y \Rightarrow (y \leqslant x))$ \\
 \hline
\end{tabular} 
\end{center}
\caption{From SET to FOL}
\label{SET2FOL}
\end{table}

\paragraph{From FOL to SMT-LIB}
An association between formulas in SMT-LIB format and formulas in first-order logic is given in the \S6 Semantics of the SMT-LIB specification\cite{SMTLIB06}.

\paragraph{From Event-B to SMT-LIB}
It is possible to derivate a translation from Event-B predicates to SMT-LIB formulas from the previous observations, as detailed in Table \ref{BPRED2SMTLIB}.
\begin{table}[htbp]
\begin{center}
\begin{tabular}{ccc}
 \textbf{Event-B predicate} & \textbf{$\rightsquigarrow$} & \textbf{SMT-LIB formula} \\ 
 $\top$ & & $\True$ \\
 $\bot$ & & $\False$ \\
 $P \land Q$ & & $(and~P~Q)$ \\
 $P \lor Q$ & & $(or~P~Q)$ \\
 $\lnot P$ & & $(not~P)$ \\
 $bool(P)$ & & $(ite~P~\True~\False)$ \\
 $P \limp Q$ & & $(implies~P~Q)$ \\
 $P \leqv Q$ & & $(iff~P~Q)$ \\
 $\forall{x}.(P)$ & & $(forall~(?x~Int)~P)$ \\
 $\exists{x}.(P)$ & & $(exists~(?x~Int)~P)$ \\
 $x = y$ & & $(=~x~y)$ \\
 $x \neq y$ & & $(not~(=~x~y))$ \\
 $x < y$ & & $(<~x~y)$ \\
 $x \leq y$ & & $(<=~x~y)$ \\
 $x > y$ & & $(>~x~y)$ \\
 $x \geq y$ & & $(>=~x~y)$ \\
\end{tabular} 
\end{center}
\caption{From Event-B predicates to SMT-LIB formulas}
\label{BPRED2SMTLIB}
\end{table}

In the same manner, the Event-B expressions can be transformed in SMT-LIB format (see Table \ref{BEXPR2SMTLIB}).

\begin{table}[htbp]
\begin{center}
\begin{tabular}{ccc}
 \textbf{Event-B expression} & \textbf{$\rightsquigarrow$} & \textbf{SMT-LIB formula} \\ 
 $x + y$ & & $(+~x~y)$ \\
 $x - y$ & & $(-~x~y)$ \\
 $-x$ & & $\sim x$ \\
 $x * y$ & & $(*~x~y)$ \\
 $x \div y$ & & $(/~x~y)$ \\
 $x \bmod y$ & & $(\%~x~y)$ \\
\end{tabular} 
\end{center}
\caption{From Event-B expressions to SMT-LIB formulas}
\label{BEXPR2SMTLIB}
\end{table}

\paragraph{Example}
How to translate the following formula $a \in b .. c$? 
The first step is to translate it as a FOL formula: 
$(a >= b) \wedge (a <= c)$. 
In Ints theory, where $a$ is defined as being an integer and $>=$ and $<=$ are defined as predicates of arity 2 on integers, it is possible to write the corresponding SMT-LIB formula: $(and~(>=~a~b)~(<=~a~c))$. 

\subsection{From Event-B sequents to benchmarks}
The SMT-LIB parser/checker version 3.0\cite{SMT-LIB} has been used to validate the format of the produced benchmarks.

\paragraph{Assumptions and Formulas}
It is possible to build a mapping between the sequents and the SMT-LIB benchmarks (see Figure 13 in \cite{SMTLIB06}): an hypothesis of a sequent is to be matched to a benchmark \textbf{assumption}; the goal of a sequent is to be matched to a benchmark \textbf{formula}. 

\paragraph{Typing Environment}
The typing environment is to be matched to benchmarks \textbf{extrasorts}, \textbf{extrapreds}, \textbf{extrafuns} and/or \textbf{assumption}. The following rules apply for the typing environment $\{t \mapsto T\}$, where identifier $t$ has type $T$:
\begin{itemize}
\item If $T$ is the $\intg$ predefined type of the Event-B 
mathematical language, the typing environment is represented 
with the  $:extrafuns~((t~Int))$ SMT-LIB declaration.
\item If $T$ is the $\Bool$ predefined type, it is
represented with the $:extrafuns~((t~Bool))$ declaration.
\item If $T$ is a carrier set, it is represented
with the $:extrafuns~((t~T))$ declaration.
\item If $T$ is a cartesian product of two basic types, i.e.\
$T = T_1~\cprod~T_2$, where $T_1$ and $T_2$ are basic types,
and $t~=~(t_1~\mapsto~t_2)$, it is represented with the 
$:extrafuns~((t_1~T_1)~(t_2~T_2))$ declaration.
\item If $T$ is a power-set of a basic type, i.e.\
$T~=~\pow(S)$, where $S$ is a basic type, it is represented 
with the $:extrasorts~((t) (S))$ declaration, and with an
additional assumption: $t \subseteq S$ (see the low-level
specification for the expected SMT-LIB syntax for this 
assumption).
\item If $T$ is a power-set of a cartesian product, i.e.\
$T~=~\pow(T_1~\cprod~T_2)$, where $T_1$ and $T_2$ are basic
types, it is represented with the $:extrafuns~((t~T_1~T_2))$ 
or the $:extrapreds~((t~T_1~T_2))$ declaration. The former
is used if $t$ is a function, and the latter if $t$ is a 
relation.
\end{itemize}

\paragraph{Theories}
The Ints theory, dedicated to integer numbers, and the Bools theory, dedicated to booleans, are the only applicable theories when considering mathematical  sequents based on the Event-B language. 

\paragraph{Logics}
Some sublogics of the main SMT-LIB logic (first-order logic with equality) are listed on the dedicated web page\cite{SMTLIB}.

Thus, QF\_LIA is for example the logic for quantifier-free linear integer arithmetic (i.e.\ boolean combinations of inequations between linear polynomials over integer variables). It refers to the Ints theory.

The linear\_order\_int and linear\_arith theories described in the taxonomy\cite{TAXO09} are to be matched to this logic. 

\paragraph{Example}
For example, if the goal for a sequent is $0 < n + 1$, under the hypothesis $n \in \nat$, in the $\{n \mapsto \intg\}$ typing environment, the associated benchmark is structured as detailed below:
\begin{align*}
(benchmark~&example.smt                      \\
           &:status~sat                      \\
           &:logic~QF\_LIA                   \\
           &:extrafuns~((n~Int))             \\
           &:assumption~(>=~n~0)             \\
           &:formula~(<~0~(+~n~1))) 
\end{align*}

\subsection{Targeted SMT Solvers}
The following SMT solvers, which support the SMT-LIB 1.2 format, have been used via the SMT plugin in the Rodin platform: 
\begin{itemize}
\item VeriT\cite{VERIT} (VeriT takes part of DECERT program and provides the possibility to use an extended SMT-Lib format).
\item Alt-Ergo\cite{ALTERGO} (Alt-Ergo takes part of DECERT program and is known to have good results with arithmetics formulas).
\item CVC3\cite{CVC3} (CVC3 si known to support many logics and is available easily for linux or windows platforms).
\item Z3\cite{Z3} (Z3 is updated regularly and available on windows platforms).
\end{itemize}

\paragraph{}
To implement the transformation from Event-B sequents to SMT-LIB benchmarks, and in particular the SET to FOL translation, we have first used the extensions to the SMT-LIB library implemented in the veriT solver, namely macro definitions and lambda expressions (see \cite{BSMT10}). However, if the targeted solver is not veriT, it is necessary to convert the Event-B sequents from the extended SMT-LIB format to the standard SMT-LIB format (see \cite{RODINSMT10}), using the $-print-simp-and-exit$ option provided by veriT.
In order to simplify the processing sequence, we now rely on the translator provided by the Predicate Prover available in Rodin (see $trunk/RodinCore/org.eventb.pptrans$, among the sources\cite{SOURCES} of the Rodin platform). 
Concerning arithmetics, we have continued from the prototype\cite{B2SMT09} implemented last year.

NB: Relations and functions are not yet fully handled and will be tackled in year 3.
